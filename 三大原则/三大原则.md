2019年11月19日13:35:01

### 单一职责原则
   * 就一个类而言,应该仅有一个引起他变化的原因  
   我们在编程的时候,会自然的给一个类添加各种功能,维护麻烦,复用不可能,也缺乏灵活性.
    
    软件设计真正要做的很多内容,就是发现职责,并把那些职责相互分离.
    如果我能够想到多于一个的动机其改变一个类,那么这个类就具有多于一个的职责.
    
   
### 开放封闭原则
   * 软件实体(类,模块,函数等)应该可以扩展,但是不可修改.
   
    对于扩展是开放的,对于更改是封闭的.
    开放封闭原则是面向对象设计的核心,可维护,可扩展,可服用,灵活性好.
    开发人员应该仅仅对程序中呈现出频繁变化的部分作出抽象,对于应用程序中的每个部分都可以进行抽象同样不是一个好主意,拒绝不成熟的抽象和抽象本身一样重要.
    所以不要过分的抽象.
    
    
### 以下两个原则有些相似:**面向接口编程**
    
    
#### 依赖倒转原则
   * 高层模块不应该依赖底层模块,两个应该都依赖抽象.
   * 抽象不应该依赖细节,细节应该依赖抽象.
   
    针对接口编程,不要对实现编程.
         
#### 里氏替换原则
   * 子类型必须能够替换他们的父类.       
     
    软件实体如果使用的是一个父类的话,那么一定适用于其子类,而行为没有发生变化,
    把父类都替换成他的子类,程序的行为没有发生变化.
    子类继承了父类,所以子类可以以父类的身份出现.
    
    只有当子类可以替换掉父类,软件单位的功能不受到影响的时候,父类才能真正的被复用,而子类也能够在父类的基础上增加新的行为.
    
    一定要学会面向抽象/接口编程.
    
    程序中的所有的依赖关系都是终止与抽象类或者接口,那就是面向对象的设计,反之那就是过程化的设计.
    
    
---    
    
    
### **接口回调:**

    public class Deal{
        public void doSth(Father father){
            father.fatherFunc();//用到接口Father的功能
            ... ...//处理其他事务
        }
    }
    
    -----------------------------------------------------------    
    Father fatherA = new SonA();
    Father fatherB = new SonB(); 
    Father fatherC = new SonC();
    
    <!--类来调用接口引用(该引用指向一个实现类的对象实例),然后接口去找他的实现类.-->
    deal.doSth(fatherA);//调用的是SonA对接口的实现
    deal.doSth(fatherB);//调用的是SonB对接口的实现
    deal.doSth(fatherC);//调用的是SonC对接口的实现

这就达到了具体实现与事务处理的解耦。  
在类Deal处理事务过程中不需要知道实现接口的子类，这样可以方便的扩充和维护代码，即设计模式的开闭原则（对扩展开放，对修改关闭）。  
上面的代码中，fatherA、fatherB、fatherC都可以称为接口回调对象，它们虽然被声明为接口Father类型，但是在实例化时却是实现的某个子类。

### **向上转型:**

    子类对象赋值给父类的引用.  A a=new B(); 
    向上转型并非是将B自动向上转型为A的对象，相反它是从另一种角度去理解向上两字的：
        它是对A的对象的方法的扩充，即A的对象只可访问B从A中继承来的和B重写A的方法。
        **其它的方法都不能访问。即使是A中的私有成员方法。a的私有成员方法不能被继承,所以子类对象没有这个方法.**